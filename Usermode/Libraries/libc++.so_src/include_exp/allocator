/*
 * Acess2 C++ Library
 * - By John Hodge (thePowersGang)
 *
 * string (header)
 * - C++'s String type
 */
#ifndef _LIBCXX_ALLOCATOR_
#define _LIBCXX_ALLOCATOR_

#include "_libcxx_helpers.h"

#include "new"
#include "cstddef"
#include "utility"

namespace std {

template <class T> class allocator
{
public:
	typedef T	value_type;
	typedef T*	pointer;
	typedef T&	reference;
	typedef const T* const_pointer;
	typedef const T&	const_reference;
	typedef size_t	size_type;
	typedef ptrdiff_t	difference_type;
	
	template <class Type>
	struct rebind
	{
		typedef allocator<Type> other;
	};
	
	allocator() throw() {
	}
	allocator(const allocator& alloc __attribute__((unused))) throw() {
	}
	template <class U>
	allocator(const allocator<U>& alloc) throw() {
	}
	~allocator() throw() {
	}
	
	pointer address(reference x) const {
		return &x;
	}
	const_pointer address(const_reference x) const {
		return &x;
	}
	pointer allocate(size_type n, const void* hint=0) {
		hint = hint;
		return static_cast<pointer>( ::operator new (n * sizeof(value_type)) );
	}
	void deallocate(pointer p, size_type n) {
		n=n;
		::operator delete(p);
	}
	size_type max_size() {
		return ((size_type)-1) / sizeof(value_type);
	}
	void construct( pointer p, const_reference val ) {
		new ((void*)p) value_type (val);
	}
	// C++11
	#if _CXX11_AVAIL
	template<class U, class... Args>
	void construct( U* p, Args&&... args ) {
		::new ((void*)p) U (::std::forward<Args>(args)...);
	}
	#endif
	void destroy(pointer p) {
		p->~value_type();
	}
};

};

#endif

// vim: ft=cpp

